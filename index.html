<!DOCTYPE html>
<meta charset="utf-8">
<body>
	<div id='svg1' height="1080" width="960"></div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.5.5/d3.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/1.11.3/jquery.min.js"></script>
<script src="emojiColors.js"></script>
<script src="emojiDictionary.js"></script>
<script src="emojiClusters.js"></script>
<script src="poisson-disc-sampler.js"></script>
<script src="confirmed.js"></script>
<script src="deaths.js"></script>
<script src="recovered.js"></script>
<input type="file">
<BR>
<script>
var liveData = null;
var emojisRenderedArray = []
var samples = []
var extractionCanvas;
var extractionCanvasContext;
var margin = 100;
scrapData()
emojiInts = emojiClustersPoints();

/**
 * For a given RGB color, find the closest match Emoji.
 *
 * @param  {array}  RGB color value.
 * @return {string} Emoji filepath.
 */
var closestCluster = function(color){
    var distance = 99999999;
    var indexClosest = 0;
	var d, p;
	for (var i=0; i<emojiInts.length; i++){
		p = emojiInts[i];
		d = Math.sqrt( Math.pow((color[0]-p[0]), 2) + Math.pow((color[1]-p[1]), 2) + Math.pow((color[2]-p[2]), 2) );
		if (d < distance){
			distance = d;
			indexClosest = i
		}
	}
	return indexClosest;
}

function scrapData()
{
	var data = null;

	var xhr = new XMLHttpRequest();
	xhr.withCredentials = false;

	xhr.addEventListener("readystatechange", function () {
		if (this.readyState === this.DONE) {
			data = JSON.parse(xhr.responseText);
			liveData = 
			{
				totalConfirmed: data["data"]["summary"]["total_cases"],
				totalRecovered: data["data"]["summary"]["recovered"],
				totalCritical: data["data"]["summary"]["critical"],
				totalActive: data["data"]["summary"]["active_cases"],
				totalDeaths: data["data"]["summary"]["deaths"]
			}
		}
	});

	xhr.open("GET", "https://coronavirus-map.p.rapidapi.com/v1/summary/latest");
	xhr.setRequestHeader("x-rapidapi-host", "coronavirus-map.p.rapidapi.com");
	xhr.setRequestHeader("x-rapidapi-key", "06bf678381msh17ecda05c62285cp19edf3jsn4d891cce6906");

	xhr.send(data);
}

function emojiClustersPoints()
{
	var pointsArray = []
	var c, r, g, b;

	for (var i=0; i<emojiClusters.length; i++){
		c = emojiClusters[i];
		r = parseInt("0x"+c.substr(1,2));
		g = parseInt("0x"+c.substr(3,2));
		b = parseInt("0x"+c.substr(5,2));
		pointsArray.push([r, g, b, c]);
	}
	return pointsArray;
}

/**
 * Create a new Emoji Mosaic.
 *
 * @param {string} dataURI
 */
function EmojiMosaic(dataURI) {
	var img = this.img = new Image;
	this.dataURI = dataURI;
	img.addEventListener( 'load', this.imageLoaded.bind( this ) );
	img.src = this.dataURI;
}

var drawCases = function(sample)
{
	var imageData, sums, i, red, green, blue, closest;
	// Get image pixel data.
	imageData = extractionCanvasContext.getImageData(Math.round( sample[0] - margin ), Math.round( sample[1] - margin ), 1, 1);

	// Get average color data for an area.
	sums = { red: 0, green: 0, blue: 0 };
	for ( i = 0; i < imageData.data.length; i++ ) {
		switch ( i % 4 ) {
			case 0:
				sums.red += imageData.data[i];
			break;
			case 1:
				sums.green += imageData.data[i];
			break;
			case 2:
				sums.blue += imageData.data[i];
			break;
		}
	}

	red = sums.red / ( imageData.data.length / 4 );
	green = sums.green / ( imageData.data.length / 4 );
	blue = sums.blue / ( imageData.data.length / 4 );

	//closest = closestEmoji( [ red, green, blue ] );
	closestClusterIndex = closestCluster( [ red, green, blue ] );
	clusterPaths = emojiDictionary[closestClusterIndex].split(',');
		
	//numEmojis = 
	idx = Math.floor(Math.random() * clusterPaths.length); 
	emojiPath = 'resized-emoji-images/' + clusterPaths[idx]

	emojiImage = new Image();
	emojiImage.src = emojiPath;
	dataX = sample[0] - 10;
	dataY = sample[1] - 10;
	emojiImage.setAttribute('data-x', (sample[0] - 10 ) );
	emojiImage.setAttribute('data-y', (sample[1] - 10 ) );
	//emojiImage.style.transform = 'rotate(180deg)';
	// After the image is loaded, draw it onto the canvas.
	emojiImage.onload = (function(event){
		var image = event.target;

		dataX = image.getAttribute('data-x');
		dataY = image.getAttribute('data-y');
		rotationAngle = Math.random() * 360;
		var svgimg = document.createElementNS('http://www.w3.org/2000/svg','image');
		svgimg.setAttribute('height','17');
		svgimg.setAttribute('width','17');
		svgimg.setAttribute('id','imageContainer');
		svgimg.setAttributeNS('http://www.w3.org/1999/xlink','href', image.src);

		svgimg.setAttribute('x', dataX);
		svgimg.setAttribute('y', dataY);
		document.getElementById('svgContainer').appendChild(svgimg)
	});
}

/*var drawCases = function(samples, startIdx, endIdx)
{
	for(var i = startIdx; i<endIdx; i++)
	{
		var imageData, sums, i, red, green, blue, closest;
		var sample = samples[i];
		// Get image pixel data.
		imageData = extractionCanvasContext.getImageData(Math.round( sample[0] - margin ), Math.round( sample[1] - margin ), 1, 1);

		// Get average color data for an area.
		sums = { red: 0, green: 0, blue: 0 };
		for ( i = 0; i < imageData.data.length; i++ ) {
			switch ( i % 4 ) {
				case 0:
					sums.red += imageData.data[i];
				break;
				case 1:
					sums.green += imageData.data[i];
				break;
				case 2:
					sums.blue += imageData.data[i];
				break;
			}
		}

		red = sums.red / ( imageData.data.length / 4 );
		green = sums.green / ( imageData.data.length / 4 );
		blue = sums.blue / ( imageData.data.length / 4 );

		//closest = closestEmoji( [ red, green, blue ] );
		closestClusterIndex = closestCluster( [ red, green, blue ] );
		clusterPaths = emojiDictionary[closestClusterIndex].split(',');
			
		//numEmojis = 
		idx = Math.floor(Math.random() * clusterPaths.length); 
		emojiPath = 'resized-emoji-images/' + clusterPaths[idx]

		emojiImage = new Image();
		emojiImage.src = emojiPath;
		dataX = sample[0] - 10;
		dataY = sample[1] - 10;
		emojiImage.setAttribute('data-x', (sample[0] - 10 ) );
		emojiImage.setAttribute('data-y', (sample[1] - 10 ) );
		//emojiImage.style.transform = 'rotate(180deg)';
		// After the image is loaded, draw it onto the canvas.
		emojiImage.onload = (function(event){
			var image = event.target;

			dataX = image.getAttribute('data-x');
			dataY = image.getAttribute('data-y');
			rotationAngle = Math.random() * 360;
			var svgimg = document.createElementNS('http://www.w3.org/2000/svg','image');
			svgimg.setAttribute('height','17');
			svgimg.setAttribute('width','17');
			svgimg.setAttribute('id','imageContainer');
			svgimg.setAttributeNS('http://www.w3.org/1999/xlink','href', image.src);

			svgimg.setAttribute('x', dataX);
			svgimg.setAttribute('y', dataY);
			document.getElementById('svgContainer').appendChild(svgimg)
		});
	}
}*/

ImageLoaded.prototype.imageLoaded = function()
{
	var  width, height, createSample, ratio;
	// If the image is too big, make the dimensions smaller.
	ratio = ( window.innerWidth ) / ( this.img.width + margin * 2 );
	this.img.height *= ratio;
	this.img.width *= ratio;
	// A canvas element for extracting image pixel color data.
	extractionCanvas = document.createElement('canvas');
	extractionCanvas.width = this.img.width;
	extractionCanvas.height = this.img.height;
	extractionCanvasContext = extractionCanvas.getContext('2d');
	extractionCanvasContext.drawImage(this.img, 0, 0, extractionCanvas.width, extractionCanvas.height );
	document.getElementById('svg1').width = extractionCanvas.width;
	document.getElementById('svg1').height = extractionCanvas.height;

	poissonWidth = extractionCanvas.width + margin * 2;
	poissonHeight = extractionCanvas.height + margin * 2;

	var svg = document.createElementNS('http://www.w3.org/2000/svg','svg');
	svg.setAttribute('xmlns:xlink','http://www.w3.org/1999/xlink');
	svg.setAttribute('id','svgContainer');
	svg.setAttribute('width', poissonWidth);
	svg.setAttribute('height', poissonHeight);
	document.getElementById('svg1').appendChild(svg)

	createSample = poissonDiscSampler(poissonWidth, poissonHeight, 3);

	// Create an array of samples (x,y coordinates) to place Emoji in.
	while (true) {
		var s = createSample();
		// If no new sample was can be made, all samples have been created.
		if (!s) break;

		// Bail if the sample is out of bounds.
		if ( s[0] < margin || s[1] < margin ) {
			continue;
		}
		if ( s[0] > poissonWidth - margin || s[1] > poissonHeight - margin ) {
			continue;
		}
		samples.push(s);
	}
	i = 0;
	timesRepeated = 0;
	timesToRepeat = Math.floor(3427343 / samples.length);
	window.setInterval(function()
	{
		console.log(i>=samples.length)
		if(i>=samples.length)
		{
			clearInterval();
		}
		else
		{
			drawCases(samples[i]);
			i++;
		}
		/*if(timesRepeated >= timesToRepeat)
		{
			clearInterval();
		}
		else
		{
			if(i>=samples.length)
			{
				timesRepeated++;
				i = 0;
			}
			drawCases(samples, i, i+10);
			i = i + 10;
		}*/
	}, 10);
}

function ImageLoaded(dataURI) {
	var img = this.img = new Image;
	this.dataURI = dataURI;
	img.addEventListener('load', this.imageLoaded.bind(this));
	img.src = this.dataURI;
}

document.addEventListener('DOMContentLoaded', function (event) {
	var inputEl = document.querySelector('input');
	document.querySelector('input').addEventListener('change', function () {
		// When a file is uploaded, initialize
		var file = inputEl.files[0];
		var reader = new FileReader();
		reader.onloadend = function () {
			new ImageLoaded(reader.result);
		}
		reader.readAsDataURL(file);
	});
});
</script>