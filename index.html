<!DOCTYPE html>
<meta charset="utf-8">
<body>
	<p>Date: <span id="datetime"></span></p>
	<!--<img id='originalImg'  src="./original-image/ad.jpg" style="display:none"/>--><!---->
	<div id='svg1' height="1080" width="960"></div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.5.5/d3.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/1.11.3/jquery.min.js"></script>
<script src="emojiColors.js"></script>
<script src="emojiDictionary2.js"></script>
<script src="emojiClusters.js"></script>
<script src="poisson-disc-sampler.js"></script>
<script src="confirmed.js"></script>
<script src="deaths.js"></script>
<script src="recovered.js"></script>
<script src="confirmedDictionary.js"></script>
<script src="emojiConfirmedDictionary.js"></script>
<script src="emojiDeathDictionary.js"></script>
<script src="emojiRecoveredDictionary.js"></script>
<script src="categories.js"></script>
<!--<input type="file">-->
<BR>
<script>
var liveData = null;
var emojisRenderedArray = []
var samples = []
var extractionCanvas;
var extractionCanvasContext;
var margin = 100;
confirmedIdxArray = [];
deathIdxArray = [];
recoveredIdxArray = [];
emojisChangeDrawn = [];
emojisConfirmedDrawn = [];
scrapData();
emojiInts = emojiClustersPoints();

var downloadSVG = function(svg)
{
	//get svg source.
	var serializer = new XMLSerializer();
	var source = serializer.serializeToString(svg);

	//add name spaces.
	if(!source.match(/^<svg[^>]+xmlns="http\:\/\/www\.w3\.org\/2000\/svg"/)){
		source = source.replace(/^<svg/, '<svg xmlns="http://www.w3.org/2000/svg"');
	}
	if(!source.match(/^<svg[^>]+"http\:\/\/www\.w3\.org\/1999\/xlink"/)){
		source = source.replace(/^<svg/, '<svg xmlns:xlink="http://www.w3.org/1999/xlink"');
	}

	//add xml declaration
	source = '<?xml version="1.0" standalone="no"?>\r\n' + source;

	//convert svg source to URI data scheme.
	var url = "data:image/svg+xml;charset=utf-8,"+encodeURIComponent(source);

	//set url value to a element's href attribute.
	var downloadLink = document.createElement("a");
	downloadLink.href = url;
	//document.getElementById("a").href = url;
	downloadLink.download = "newesttree.svg";
	document.body.appendChild(downloadLink);
	downloadLink.click();
	document.body.removeChild(downloadLink);
}

/**
 * For a given RGB color, find the closest match Emoji.
 *
 * @param  {array}  RGB color value.
 * @return {string} Emoji filepath.
 */
var closestCluster = function(color){
    var distance = 99999999;
    var indexClosest = 0;
	var d, p;
	for (var i=0; i<emojiInts.length; i++){
		p = emojiInts[i];
		d = Math.sqrt( Math.pow((color[0]-p[0]), 2) + Math.pow((color[1]-p[1]), 2) + Math.pow((color[2]-p[2]), 2) );
		if (d < distance){
			distance = d;
			indexClosest = i
		}
	}
	return indexClosest;
}

function scrapData()
{
	var data = null;

	var xhr = new XMLHttpRequest();
	xhr.withCredentials = false;

	xhr.addEventListener("readystatechange", function () {
		if (this.readyState === this.DONE) {
			data = JSON.parse(xhr.responseText);
			liveData = 
			{
				totalConfirmed: data["data"]["summary"]["total_cases"],
				totalRecovered: data["data"]["summary"]["recovered"],
				totalCritical: data["data"]["summary"]["critical"],
				totalActive: data["data"]["summary"]["active_cases"],
				totalDeaths: data["data"]["summary"]["deaths"]
			}
		}
	});

	xhr.open("GET", "https://coronavirus-map.p.rapidapi.com/v1/summary/latest");
	xhr.setRequestHeader("x-rapidapi-host", "coronavirus-map.p.rapidapi.com");
	xhr.setRequestHeader("x-rapidapi-key", "06bf678381msh17ecda05c62285cp19edf3jsn4d891cce6906");

	xhr.send(data);
}

function emojiClustersPoints()
{
	var pointsArray = []
	var c, r, g, b;

	for (var i=0; i<emojiClusters.length; i++){
		c = emojiClusters[i];
		r = parseInt("0x"+c.substr(1,2));
		g = parseInt("0x"+c.substr(3,2));
		b = parseInt("0x"+c.substr(5,2));
		pointsArray.push([r, g, b, c]);
	}
	return pointsArray;
}

/**
 * Create a new Emoji Mosaic.
 *
 * @param {string} dataURI
 */
function EmojiMosaic(dataURI) {
	var img = this.img = new Image;
	this.dataURI = dataURI;
	img.addEventListener( 'load', this.imageLoaded.bind( this ) );
	img.src = this.dataURI;
}

var drawCasesSamplesOnce = function(sample, category)
{
	imageData = extractionCanvasContext.getImageData(Math.round( sample[0] - margin ), Math.round( sample[1] - margin ), 1, 1);

	// Get average color data for an area.
	sums = { red: 0, green: 0, blue: 0 };
	for ( i = 0; i < imageData.data.length; i++ ) {
		switch ( i % 4 ) {
			case 0:
				sums.red += imageData.data[i];
			break;
			case 1:
				sums.green += imageData.data[i];
			break;
			case 2:
				sums.blue += imageData.data[i];
			break;
		}
	}

	red = sums.red / ( imageData.data.length / 4 );
	green = sums.green / ( imageData.data.length / 4 );
	blue = sums.blue / ( imageData.data.length / 4 );

	//closest = closestEmoji( [ red, green, blue ] );
	closestClusterIndex = closestCluster( [ red, green, blue ] );
	//clusterPathsAvailable = emojiDictionary[closestClusterIndex][category];
	if(category=="confirmed")
	{
		clusterPathsAvailable = emojiConfirmedDictionary[closestClusterIndex];
	}
	else if(category=="death")
	{
		clusterPathsAvailable = emojiDeathDictionary[closestClusterIndex];
	}
	else if(category=='recovered')
	{
		clusterPathsAvailable = emojiRecoveredDictionary[closestClusterIndex];
	}
	else if(category=='change')
	{
		clusterPathsAvailable = ["092.png"];
	}
	//clusterPathsAvailable = emojiDictionary2[closestClusterIndex];
	if(clusterPathsAvailable)
	{
		idx = Math.floor(Math.random() * clusterPathsAvailable.length);
		/*if(typeof clusterPathsAvailable[idx]!='undefined')
		{*/
		emojiPath = 'resized-emoji-images/' + clusterPathsAvailable[idx];
		//}
	}

	if(emojiPath)
	{
		emojiImage = new Image();
		emojiImage.src = emojiPath;
		dataX = sample[0] - 10;
		dataY = sample[1] - 10;
		emojiImage.setAttribute('data-x', (sample[0] - 10 ) );
		emojiImage.setAttribute('data-y', (sample[1] - 10 ) );
		//emojiImage.style.transform = 'rotate(180deg)';
		// After the image is loaded, draw it onto the canvas.
		emojiImage.onload = (function(event){
			var image = event.target;

			if(category=='change')
			{
				//pick randomly a confirmed case to interchange with a death one
				removalIdx = Math.floor(Math.random() * emojisConfirmedDrawn.length);
				emojiToRemove = emojisConfirmedDrawn[removalIdx];
				//remove it from document
				document.getElementById('svgContainer').removeChild(emojiToRemove);
				emojisConfirmedDrawn.splice(removalIdx,1);
			}
			else if(category=='death' || category=='recovered')
			{
				//pick randomly a confirmed case to interchange with a death one
				removalIdx = Math.floor(Math.random() * emojisChangeDrawn.length);
				emojiToRemove = emojisChangeDrawn[removalIdx];
				//remove it from document
				document.getElementById('svgContainer').removeChild(emojiToRemove);
				emojisChangeDrawn.splice(removalIdx,1);
			}


			dataX = image.getAttribute('data-x');
			dataY = image.getAttribute('data-y');
			rotationAngle = Math.random() * 360;
			var svgimg = document.createElementNS('http://www.w3.org/2000/svg','image');
			/*svgimg.setAttribute('height','17');
			svgimg.setAttribute('width','17');*/
			svgimg.setAttribute('height','10');
			svgimg.setAttribute('width','10');
			svgimg.setAttribute('id','imageContainer');
			svgimg.setAttributeNS('http://www.w3.org/1999/xlink','href', image.src);

			svgimg.setAttribute('x', dataX);
			svgimg.setAttribute('y', dataY);
			document.getElementById('svgContainer').appendChild(svgimg);
			if(category == 'confirmed')
			{
				emojisConfirmedDrawn.push(svgimg);
				//check if date needs to be changed and save file with svg
				numChildrenSVG = document.getElementById('svgContainer').children.length;
				if(confirmedDictionary[numChildrenSVG])
				{
					dateConfirmed = confirmedDictionary[numChildrenSVG];
					var dt = new Date(dateConfirmed);
					document.getElementById("datetime").innerHTML = dt.toLocaleDateString();
					//get svg element.
					/*var svg = document.getElementById("svgContainer");	
					downloadSVG(svg);*/
				}
			}
			else if(category=='change')
			{
				emojisChangeDrawn.push(svgimg);
			}
				/*else if(category == 'change')
				{
					emojisChangeDrawn.push(svgimg);
				}*/
		});
	}
	/*else
	{
		var svgimg = document.createElementNS('http://www.w3.org/2000/svg','image');
		svgimg.setAttribute('x', dataX);
		svgimg.setAttribute('y', dataY);
		
	}*/
}

Date.prototype.formatMMDDYYYY = function(){
    return (this.getMonth() + 1) + 
    "/" +  this.getDate() +
    "/" +  (String(parseInt(this.getYear()) - 100));
}

ImageLoaded.prototype.imageLoaded = function()
{
	var  width, height, createSample, ratio;
	// If the image is too big, make the dimensions smaller.
	this.ratio = ( window.innerWidth ) / ( this.img.width + margin * 2 );
	this.img.height *= ratio;
	this.img.width *= ratio;

	// A canvas element for extracting image pixel color data.
	extractionCanvas = document.createElement('canvas');
	extractionCanvas.width = this.img.height;
	extractionCanvas.height = this.img.width;
	extractionCanvasContext = extractionCanvas.getContext('2d');
	extractionCanvasContext.drawImage(this.img, 0, 0, extractionCanvas.width, extractionCanvas.height );
	document.getElementById('svg1').width = extractionCanvas.width;
	document.getElementById('svg1').height = extractionCanvas.height;

	poissonWidth = extractionCanvas.width + margin * 2;
	poissonHeight = extractionCanvas.height + margin * 2;

	var svg = document.createElementNS('http://www.w3.org/2000/svg','svg');
	svg.setAttribute('xmlns:xlink','http://www.w3.org/1999/xlink');
	svg.setAttribute('id','svgContainer');
	svg.setAttribute('width', poissonWidth);
	svg.setAttribute('height', poissonHeight);
	document.getElementById('svg1').appendChild(svg)

	createSample = poissonDiscSampler(poissonWidth, poissonHeight, 3);

	// Create an array of samples (x,y coordinates) to place Emoji in.
	while (true) {
		var s = createSample();
		// If no new sample was can be made, all samples have been created.
		if (!s) break;

		// Bail if the sample is out of bounds.
		if ( s[0] < margin || s[1] < margin ) {
			continue;
		}
		if ( s[0] > poissonWidth - margin || s[1] > poissonHeight - margin ) {
			continue;
		}
		samples.push(s);
	}
	casesDrawn = 0;
	samplesIdx = 0; //last position used in samples array
	casesToDraw = parseInt(Object.keys(confirmed)[Object.keys(confirmed).length - 1]);
	casesToDraw = 3427343;
	var dt = new Date("1/22/20");
	document.getElementById("datetime").innerHTML = dt.toLocaleDateString();
	lastIdx = 0;

	//good old one
	//for(var i=0; i<1; i++)
	for(var i=0; i<Object.keys(confirmed).length - 1;i++)
	{
		confirmedCasesToDraw = confirmed[Object.keys(confirmed)[i]];
		deathCasesToDraw = deaths[Object.keys(confirmed)[i]];
		recoveredCasesToDraw = recovered[Object.keys(confirmed)[i]];
		wavesCasesToDraw = deathCasesToDraw + recoveredCasesToDraw;
		confirmedCasesDrawn = 0;
		deathCasesDrawn = 0;
		recoveredCasesDrawn = 0;
		wavesCasesDrawn = 0;

		//first draw the confirmed cases
		window.setInterval(function()
		{	
			if(confirmedCasesDrawn>=confirmedCasesToDraw)
			{
				clearInterval();
			}
			else
			{
				if(samplesIdx<samples.length)
				{
					sample = samples[samplesIdx];
					drawCasesSamplesOnce(samples[samplesIdx], 'confirmed');
				}
				else
				{
					samplesIdx = 0;
					sample = samples[samplesIdx];
					drawCasesSamplesOnce(samples[samplesIdx], 'confirmed');
				}

				samplesIdx++;
				confirmedCasesDrawn++;
				if(confirmedDictionary[String(casesDrawn)])
				{
					dt = new Date(confirmedDictionary[String(confirmedCasesDrawn)]);
					document.getElementById("datetime").innerHTML = dt.toLocaleDateString();
				}
			}
		}, 0.00000000000000000000000000001);

		//before drawing anything else draw the waves for change
		window.setInterval(function()
		{	
			if(wavesCasesDrawn>=wavesCasesToDraw)
			{
				clearInterval();
			}
			else
			{
				if(emojisConfirmedDrawn.length>0)
				{
					//pick randomly a confirmed case to interchange with a death one
					/*removalIdx = Math.floor(Math.random() * emojisConfirmedDrawn.length)
					emojiToRemove = emojisConfirmedDrawn[removalIdx];
					//get coordinates
					dataX = emojiToRemove.getAttribute('x');
					dataY = emojiToRemove.getAttribute('y');
					//remove it from document
					document.getElementById('svgContainer').removeChild(emojiToRemove)
					emojisConfirmedDrawn.splice(removalIdx,1)*/
					drawCasesSamplesOnce([dataX, dataY], "change");
				}
			}
		}, 0.00000000000000000000000000001);
	
		//second draw the death cases
		window.setInterval(function()
		{	
			if(deathCasesDrawn>=deathCasesToDraw)
			{
				clearInterval();
			}
			else
			{
				if(emojisChangeDrawn.length>0)
				{
					//pick randomly a confirmed case to interchange with a death one
					/*removalIdx = Math.floor(Math.random() * emojisChangeDrawn.length)
					emojiToRemove = emojisChangeDrawn[removalIdx];
					//get coordinates
					dataX = emojiToRemove.getAttribute('x');
					dataY = emojiToRemove.getAttribute('y');
					//remove it from document
					document.getElementById('svgContainer').removeChild(emojiToRemove)
					emojisChangeDrawn.splice(removalIdx,1);*/
					drawCasesSamplesOnce([dataX, dataY], "death");
				}
			}
		}, 0.00000000000000000000000000001);

		//third draw the recovered cases
		window.setInterval(function()
		{	
			if(recoveredCasesDrawn>=recoveredCasesToDraw)
			{
				clearInterval();
			}
			else
			{
				if(wavesCasesDrawn.length>0)
				{
					//pick randomly a confirmed case to interchange with a death one
					/*removalIdx = Math.floor(Math.random() * wavesCasesDrawn.length)
					emojiToRemove = wavesCasesDrawn[removalIdx];
					//get coordinates
					dataX = emojiToRemove.getAttribute('x');
					dataY = emojiToRemove.getAttribute('y');
					//remove it from document
					document.getElementById('svgContainer').removeChild(emojiToRemove)
					wavesCasesDrawn.splice(removalIdx,1)*/
					drawCasesSamplesOnce([dataX, dataY], "recovered");
				}
			}
		}, 0.00000000000000000000000000001);
	}
}

function ImageLoaded(dataURI) {
	var img = this.img = new Image;
	this.dataURI = dataURI;
	img.addEventListener('load', this.imageLoaded.bind(this));
	//img.addEventListener('load', this.imageLoaded(img))
	img.src = this.dataURI;
}

document.addEventListener('DOMContentLoaded', function (event) 
{ 	
	//imageLoaded();
	new ImageLoaded('./original-image/ad.jpg');
});
</script>